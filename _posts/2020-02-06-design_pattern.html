---
layout: post
title: "소프트웨어 디자인 패턴"
subtitle: "자주 발생하는 문제를 피하는 방법론"
date: 2020-02-06 18:15:00
background: '/img/posts/06.jpg'
---

<h3>디자인 패턴</h3>
<p>디자인 패턴이란, 소프트웨어를 설계할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴을 뜻합니다.</p>
<p>코드를 수정하거나 새로운 기능을 추가할 때 
  의도치 않은 결과나 버그를 발생을 줄여줌으로 시간과 예산 소모를 줄입니다.</p>

<h4>디자인 패턴의 분류</h4>
<p>디자인 패턴은 목적에 따라서 '생선 패턴', '구조 패턴', '행동 패턴'으로 나뉩니다.</p>

<h5>생성 패턴</h5>
<p>객체의 생성에 관련된 패턴, 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.</p>
<ul>
  <li><b>싱글톤(Singleton) 패턴</b> : 
    클래스의 인스턴스가 하나임을 보장하고 접근할 수 있는 전역적인 접근점을 제공하는 패턴으로, 디자인 패턴의 가장 기초라고 할 수 있습니다.</li>
  <li><b>추상팩토리(Abstract Factory) 패턴</b> : 
    많은 수의 연관된 서브 클래스를 특정 그룹으로 묶어 한번에 교체할 수 있도록 만드는 패턴입니다.</li>
  <li><b>팩토리 메서드(Factory Method) 패턴</b> : 
    객체를 만들어 반환하는 함수를 (생성자 대신) 제공하여 초기화 과정을 외부에서 보지 못하게 숨기고 반환 타입을 제어하는 방법.
  </li>
  <li><b>빌더(Builder) 패턴</b> : 
    인스턴스를 생성자를 통해 직접 생성하지않고, 빌더라는 내부 클래스를 통해 간접적으로 생성하게 하는 패턴입니다.
    클래스와 사용 대상의 결합도를 낮추기 위해, 생성자에 전달하는 인수에 의미를 부여하기 위해 사용됩니다. 팩토리 패턴과 유사합니다.
  </li>
  <li><b>프로토타입(Prototype) 패턴</b> : 
    원본(Prototype)을 만들어 놓고 원본 객체를 복사하여 사용하는 방식입니다.
  </li>
</ul>

<h5>구조 패턴</h5>
<p>클래스나 객체를 조합해 더 큰 구조를 만드는 패턴</p>
<ul>
  <li><b>어댑터(Adapter) 패턴</b> : 
    한 클래스의 인터페이스를 사용하고자 하는 다른 인터페이스로 변환할 때 주로 사용하며, 이를 이용하면 인터페이스 호환성이 맞지 않아 같이 쓸 수 없는 클래스를 연관 관계로
    연결해서 사용할 수 있게 해주는 패턴
  </li>
  <li><b>브리지(Bridge) 패턴</b> : 
    구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 합니다. 즉, 기능과 구현에 대해서 두 개를 별도의 클래스로 구현하는 패턴
  </li>
  <li><b>컴퍼지트(Composite) 패턴</b> : 
    여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
  </li>
  <li><b>데커레이터(Decorator) 패턴</b> : 
    객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
  </li>
  <li><b>퍼사드(Facade) 패턴</b> : 
    복잡한 호출과정을 대신 처리해주는 wrapper객체를 따로 만드는 것. 함수 호출 비용이 조금 들어가거나 훨씬 쉽게 사용할 수 있습니다. 
    하위 모듈을 건드릴 수 없는 경우나 저수준과 고수준 추상층 개념을 구분하고 싶은 경우, 크로스플랫폼 기술 구현 등의 이유가 있습니다.
  </li>
  <li><b>플라이웨이트(Flyweight) 패턴</b> : 
    
  </li>
  <li><b>프록시(Proxy) 패턴</b> : 
    연산을 할 때 객체 스스로가 직접 처리하지 않고 중간에 다른 '숨겨진' 객체를 통해 처리하는 방법
  </li>
</ul>

<h5>행위 패턴</h5>
<ul>
  <li><b>옵저버(Observer) 패턴</b> : 
    한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는 패턴
  </li>
  <li><b>스테이트(State) 패턴</b> : 
    객체의 상태에 따라 객체의 행위 내용을 변경해주는 패턴
  </li>
  <li><b>스트래티지(Strategy) 패턴</b> : 
    행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
  </li>
  <li><b>템플릿 메서드(Template Method) 패턴</b> : 
    어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는
    내역을 바꾸는 패턴
  </li>
  <li><b>커맨드(Command) 패턴</b> : 
    실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴
  </li>

</ul>



<div id="references">
  <h4>참조</h4>
  <ul>
    <li>
      <a href="https://namu.wiki/w/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4">나무위키</a>
    </li>
    <li>
      <a href="https://gmlwjd9405.github.io/2018/07/06/design-pattern.html">https://gmlwjd9405.github.io/2018/07/06/design-pattern.html</a>
    </li>
    <li>
      <a href="https://cafe.naver.com/dditorkr/512">https://cafe.naver.com/dditorkr/512</a>
    </li>
    <li>
      <a href="https://niceman.tistory.com/141?category=940951">https://niceman.tistory.com/141?category=940951</a>
    </li>
    <li>
      <a href="https://lktprogrammer.tistory.com/35">https://lktprogrammer.tistory.com/35</a>
    </li>
  </ul>
</div>
